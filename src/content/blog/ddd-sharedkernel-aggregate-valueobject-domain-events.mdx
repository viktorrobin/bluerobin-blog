---
title: "Building a DDD SharedKernel: AggregateRoot, ValueObject, and Domain Events"
description: "A practical guide to implementing Domain-Driven Design building blocks in .NET—with production-tested code from the BlueRobin project."
pubDate: 2026-01-21
author: "Victor Rentea"
category: "architecture"
difficulty: "intermediate"
tags: ["ddd-series", "dotnet", "clean-architecture", "design-patterns"]
series: "ddd-series"
seriesOrder: 1
readTime: "12 min"
toc: true
featured: true
---

import Callout from '@components/Callout.astro';
import ImplementationNote from '@components/ImplementationNote.astro';
import ExternalCite from '@components/ExternalCite.astro';

Domain-Driven Design (DDD) provides tactical patterns for modeling complex business domains. The **SharedKernel** is a reusable foundation containing base classes and interfaces that every bounded context builds upon: `Entity`, `AggregateRoot`, `ValueObject`, and `DomainEvent`.

This article walks through implementing these building blocks in .NET, based on the production code running in BlueRobin—a personal document management system.

## Why a SharedKernel?

Before diving into code, let's understand why we need these abstractions:

| Building Block | Purpose |
|----------------|---------|
| **Entity** | Objects with identity that persists over time |
| **Value Object** | Immutable objects defined by their attributes, not identity |
| **Aggregate Root** | Entity that controls access to a cluster of objects |
| **Domain Event** | Record of something that happened in the domain |

<ExternalCite 
  title="Domain-Driven Design: Tackling Complexity in the Heart of Software" 
  url="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" 
  author="Eric Evans"
  date="2003"
/>

## Project Structure

```
src/
└── SharedKernel/
    ├── Entity.cs
    ├── AggregateRoot.cs
    ├── ValueObject.cs
    ├── DomainEvent.cs
    ├── Interfaces/
    │   ├── IAggregateRoot.cs
    │   └── IDomainEvent.cs
    ├── Exceptions/
    │   └── DomainException.cs
    └── Utilities/
        └── BlueRobinId.cs
```

## The Entity Base Class

Entities have **identity**. Two entities are equal if they have the same ID, regardless of their other properties.

```csharp
using BlueRobin.SharedKernel.Utilities;

namespace BlueRobin.SharedKernel;

public abstract class Entity
{
    protected Entity(string? id = null)
    {
        if (string.IsNullOrEmpty(id))
        {
            Id = BlueRobinId.New();
        }
        else
        {
            if (BlueRobinId.TryParse(id, out var blueRobinId))
                Id = blueRobinId;
            else
                throw new ArgumentException("Id is not a valid BlueRobin Id", nameof(id));
        }
    }

    public BlueRobinId Id { get; protected set; }
}
```

### Key Design Decisions

1. **Protected constructor** — Forces derived classes to explicitly handle ID assignment
2. **Strongly-typed ID** — Uses `BlueRobinId` instead of `string` or `Guid` (more on this below)
3. **Auto-generation** — New IDs created automatically when none provided

<ImplementationNote>
BlueRobin uses 8-character alphanumeric IDs (e.g., `abc12xyz`) instead of GUIDs. They're URL-safe, readable in logs, and efficient for display. The trade-off is reduced uniqueness guarantees—acceptable for a single-tenant system but would need adjustment for multi-tenant scenarios.
</ImplementationNote>

## The BlueRobinId Value Object

Rather than using raw strings or GUIDs for entity IDs, BlueRobin uses a strongly-typed ID:

```csharp
using System.Text.RegularExpressions;
using NanoidDotNet;

namespace BlueRobin.SharedKernel.Utilities;

/// <summary>
/// Unique identifier used throughout BlueRobin for all entities.
/// 8 characters, lowercase alphanumeric only for URL-safety and readability.
/// </summary>
public readonly partial struct BlueRobinId : IEquatable<BlueRobinId>
{
    private const string Alphabet = "0123456789abcdefghijklmnopqrstuvwxyz";
    private const int IdSize = 8;

    // Source-generated regex for validation (performance optimization)
    [GeneratedRegex($"^[{Alphabet}]+$", RegexOptions.Compiled)]
    private static partial Regex ValidPattern();

    public string Value { get; }

    public BlueRobinId(string? id)
    {
        if (id == null)
            throw new ArgumentNullException(nameof(id), "BlueRobinId cannot be null.");

        if (string.IsNullOrEmpty(id) || !IsValidFormat(id))
            throw new ArgumentException(
                $"Invalid BlueRobinId format. Must be 1-{IdSize} lowercase alphanumeric characters.",
                nameof(id));
        Value = id;
    }

    /// <summary>
    /// Generates a new BlueRobinId using secure random generation.
    /// </summary>
    public static BlueRobinId New()
    {
        return new BlueRobinId(Nanoid.Generate(Alphabet, IdSize));
    }

    public static BlueRobinId From(string value)
    {
        if (string.IsNullOrEmpty(value))
            throw new ArgumentException("BlueRobinId cannot be empty", nameof(value));
        return new BlueRobinId(value);
    }

    public static bool TryParse(string id, out BlueRobinId blueRobinId)
    {
        if (IsValidFormat(id))
        {
            blueRobinId = new BlueRobinId(id);
            return true;
        }
        blueRobinId = default;
        return false;
    }

    private static bool IsValidFormat(string id)
    {
        if (string.IsNullOrEmpty(id)) return false;
        if (id.Length > IdSize) return false;
        return ValidPattern().IsMatch(id);
    }

    // Equality implementation
    public override bool Equals(object? obj) => obj is BlueRobinId other && Equals(other);
    public bool Equals(BlueRobinId other) => string.Equals(Value, other.Value, StringComparison.Ordinal);
    public override int GetHashCode() => Value.GetHashCode(StringComparison.Ordinal);
    public override string ToString() => Value;

    public static bool operator ==(BlueRobinId left, BlueRobinId right) => left.Equals(right);
    public static bool operator !=(BlueRobinId left, BlueRobinId right) => !left.Equals(right);
}
```

### Why Strongly-Typed IDs?

- **Compile-time safety** — Can't accidentally pass a `userId` where a `documentId` is expected
- **Validation at construction** — Invalid formats fail fast
- **Self-documenting code** — `BlueRobinId` is more meaningful than `string`

<ExternalCite 
  title="Using strongly-typed entity IDs to avoid primitive obsession" 
  url="https://andrewlock.net/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/" 
  author="Andrew Lock"
/>

## The ValueObject Base Class

Value Objects are immutable and compared by their attributes, not identity. Two `Money` objects with the same amount and currency are equal, even if they're different instances.

```csharp
namespace BlueRobin.SharedKernel;

public abstract class ValueObject
{
    protected static bool EqualOperator(ValueObject? left, ValueObject? right)
    {
        if (left is null ^ right is null) return false;
        return left is null || left.Equals(right);
    }

    protected static bool NotEqualOperator(ValueObject? left, ValueObject? right)
    {
        return !EqualOperator(left, right);
    }

    protected abstract IEnumerable<object> GetEqualityComponents();

    public override bool Equals(object? obj)
    {
        if (obj == null || obj.GetType() != GetType()) return false;

        var other = (ValueObject)obj;
        return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
    }

    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Select(x => x != null ? x.GetHashCode() : 0)
            .Aggregate((x, y) => x ^ y);
    }
}
```

### Usage Example: FingerPrint

Here's a real value object from BlueRobin representing a document's SHA-256 hash:

```csharp
namespace BlueRobin.Archives.Core.ValueObjects;

public class FingerPrint : ValueObject
{
    public string Value { get; }

    private FingerPrint(string value)
    {
        Value = value ?? throw new ArgumentNullException(nameof(value));
    }

    public static FingerPrint FromHash(string hash)
    {
        if (string.IsNullOrWhiteSpace(hash))
            throw new ArgumentException("Hash cannot be empty", nameof(hash));
            
        if (hash.Length != 64) // SHA-256 produces 64 hex characters
            throw new ArgumentException("Invalid SHA-256 hash length", nameof(hash));
            
        return new FingerPrint(hash.ToLowerInvariant());
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Value;
    }

    public override string ToString() => Value;
}
```

<Callout type="tip">
Value objects should be **immutable**. If you need to change a value, create a new instance. This eliminates a whole class of bugs related to shared mutable state.
</Callout>

## The AggregateRoot Class

Aggregates are clusters of entities and value objects treated as a single unit for data changes. The **Aggregate Root** is the entry point—all modifications go through it.

```csharp
using BlueRobin.SharedKernel.Interfaces;

namespace BlueRobin.SharedKernel;

public class AggregateRoot : Entity, IAggregateRoot
{
    private readonly List<IDomainEvent> _domainEvents = new();
    public IReadOnlyCollection<IDomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    public IReadOnlyCollection<IDomainEvent> GetDomainEvents()
    {
        return _domainEvents.AsReadOnly();
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }

    protected void RaiseDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }
}
```

### Key Points

1. **Event collection** — Aggregate roots collect domain events during operations
2. **Protected `RaiseDomainEvent`** — Only the aggregate can raise events, enforcing encapsulation
3. **`ClearDomainEvents`** — Called after events are dispatched (typically by the repository/unit of work)

## Domain Events

Domain events capture **something that happened** that domain experts care about. They're dispatched after the aggregate is persisted.

```csharp
using BlueRobin.SharedKernel.Interfaces;

namespace BlueRobin.SharedKernel;

public abstract class DomainEvent : IDomainEvent
{
    protected DomainEvent()
    {
        EventId = Guid.NewGuid();
        OccurredOnUtc = DateTime.UtcNow;
    }

    public Guid EventId { get; }
    public DateTime OccurredOnUtc { get; }
}
```

### The IDomainEvent Interface

Note that `IDomainEvent` implements MediatR's `INotification`. This enables in-process event handling via MediatR's notification system:

```csharp
using MediatR;

namespace BlueRobin.SharedKernel.Interfaces;

public interface IDomainEvent : INotification
{
    Guid EventId { get; }
    DateTime OccurredOnUtc { get; }
}
```

<ExternalCite 
  title="MediatR Wiki - Notifications" 
  url="https://github.com/jbogard/MediatR/wiki#notifications"
/>

### Usage Example: DocumentAddedEvent

```csharp
using BlueRobin.SharedKernel;
using BlueRobin.SharedKernel.Utilities;

namespace BlueRobin.Archives.Core.Events;

public class DocumentAddedEvent : DomainEvent
{
    public DocumentAddedEvent(
        BlueRobinId documentId,
        BlueRobinId archiveId,
        BlueRobinId createdBy,
        string fileName,
        string contentType,
        long fileSize,
        string objectName)
    {
        DocumentId = documentId;
        ArchiveId = archiveId;
        CreatedBy = createdBy;
        FileName = fileName;
        ContentType = contentType;
        FileSize = fileSize;
        ObjectName = objectName;
    }

    public BlueRobinId DocumentId { get; }
    public BlueRobinId ArchiveId { get; }
    public BlueRobinId CreatedBy { get; }
    public string FileName { get; }
    public string ContentType { get; }
    public long FileSize { get; }
    public string ObjectName { get; }
}
```

## Putting It All Together: The Document Aggregate

Here's how the `Document` aggregate uses all these building blocks:

```csharp
using BlueRobin.Archives.Core.Enums;
using BlueRobin.Archives.Core.Events;
using BlueRobin.Archives.Core.ValueObjects;
using BlueRobin.SharedKernel;
using BlueRobin.SharedKernel.Utilities;

namespace BlueRobin.Archives.Core.Entities;

public class Document : AggregateRoot
{
    // Private constructor for EF Core
    private Document()
    {
        Metadata = null!;
        Analysis = null!;
        Classification = null!;
        Metrics = null!;
    }

    #region Factory Methods

    /// <summary>
    /// Creates a new document entity.
    /// </summary>
    public static Document Create(
        BlueRobinId archiveId,
        BlueRobinId createdBy,
        FingerPrint fingerPrint,
        string fileName,
        long fileSize,
        string contentType)
    {
        var id = BlueRobinId.New();

        var metadata = DocumentMetadata.CreateWithGeneratedObjectName(
            id.Value,
            fileName,
            contentType,
            fileSize,
            fingerPrint);

        var document = new Document
        {
            Id = id,
            ArchiveId = archiveId,
            CreatedBy = createdBy,
            Metadata = metadata,
            Status = DocumentStatus.Pending,
            CreatedOnUtc = DateTime.UtcNow,
            Classification = DocumentClassification.Unclassified(),
            Analysis = DocumentAnalysis.Empty(),
            Metrics = ProcessingMetrics.Empty()
        };

        // Raise domain event for downstream processing
        document.RaiseDomainEvent(new DocumentAddedEvent(
            document.Id,
            archiveId,
            createdBy,
            fileName,
            contentType,
            fileSize,
            document.ObjectName));

        return document;
    }

    #endregion

    // Properties
    public BlueRobinId ArchiveId { get; private set; }
    public BlueRobinId CreatedBy { get; private set; }
    public DocumentMetadata Metadata { get; private set; }
    public DocumentStatus Status { get; private set; }
    public DateTime CreatedOnUtc { get; private set; }
    public DocumentClassification Classification { get; private set; }
    public DocumentAnalysis Analysis { get; private set; }
    public ProcessingMetrics Metrics { get; private set; }
}
```

### Why Factory Methods Instead of Public Constructors?

1. **Validation** — Factory methods can validate all inputs before creating the entity
2. **Invariants** — Ensures the entity is always created in a valid state
3. **Events** — The right place to raise "created" domain events
4. **Named constructors** — `Document.Create()` is more readable than `new Document(...)`

<Callout type="warning">
The private parameterless constructor is required for EF Core to materialize entities from the database. It bypasses validation because we trust data already in the database was validated on entry.
</Callout>

## Domain Exceptions

When domain rules are violated, throw domain-specific exceptions:

```csharp
namespace BlueRobin.SharedKernel.Exceptions;

public class DomainException : Exception
{
    public DomainException() { }
    public DomainException(string message) : base(message) { }
    public DomainException(string message, Exception innerException) 
        : base(message, innerException) { }
}

public class EntityNotFoundException : DomainException
{
    public EntityNotFoundException(string entityType, string entityId)
        : base($"{entityType} with ID '{entityId}' was not found.")
    {
        EntityType = entityType;
        EntityId = entityId;
    }

    public string? EntityType { get; }
    public string? EntityId { get; }
}
```

These can be caught by exception handling middleware and converted to appropriate HTTP responses (e.g., `EntityNotFoundException` → 404 Not Found).

## Testing the SharedKernel

Each building block should have its own tests. Here's an example for `ValueObject`:

```csharp
public class ValueObjectTests
{
    private class TestValueObject : ValueObject
    {
        public string Value1 { get; }
        public int Value2 { get; }

        public TestValueObject(string value1, int value2)
        {
            Value1 = value1;
            Value2 = value2;
        }

        protected override IEnumerable<object> GetEqualityComponents()
        {
            yield return Value1;
            yield return Value2;
        }
    }

    [Fact]
    public void ValueObjects_WithSameValues_AreEqual()
    {
        var vo1 = new TestValueObject("test", 42);
        var vo2 = new TestValueObject("test", 42);

        Assert.Equal(vo1, vo2);
        Assert.Equal(vo1.GetHashCode(), vo2.GetHashCode());
    }

    [Fact]
    public void ValueObjects_WithDifferentValues_AreNotEqual()
    {
        var vo1 = new TestValueObject("test", 42);
        var vo2 = new TestValueObject("different", 42);

        Assert.NotEqual(vo1, vo2);
    }
}
```

## Summary

The SharedKernel provides the foundation for Domain-Driven Design:

| Component | Responsibility |
|-----------|---------------|
| `Entity` | Identity-based equality, auto-generated IDs |
| `BlueRobinId` | Strongly-typed, validated identifiers |
| `ValueObject` | Attribute-based equality, immutability |
| `AggregateRoot` | Transaction boundary, domain event collection |
| `DomainEvent` | Record of domain occurrences |
| `DomainException` | Domain rule violation signaling |

In the next article, we'll explore **factory methods and private constructors** in more detail—how to enforce domain invariants and ensure entities are always valid.

---

## References

<ExternalCite 
  title="Domain-Driven Design: Tackling Complexity in the Heart of Software" 
  url="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215" 
  author="Eric Evans"
  date="2003"
/>

<ExternalCite 
  title="Implementing Domain-Driven Design" 
  url="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" 
  author="Vaughn Vernon"
  date="2013"
/>

<ExternalCite 
  title="Domain-Driven Design in .NET" 
  url="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice" 
  author="Microsoft Docs"
/>
